#!/usr/bin/env php
<?php

require_once __DIR__ . "/vendor/autoload.php";

use Ahc\Cli\Input\Command;
use cebe\openapi\spec\Info;
use cebe\openapi\spec\MediaType;
use cebe\openapi\spec\OpenApi;
use cebe\openapi\spec\Operation;
use cebe\openapi\spec\Parameter;
use cebe\openapi\spec\PathItem;
use cebe\openapi\spec\Response;
use cebe\openapi\spec\Schema;
use cebe\openapi\spec\SecurityRequirement;
use cebe\openapi\Writer;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Expr\ClassConstFetch;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Expr\New_;
use PhpParser\Node\Expr\UnaryMinus;
use PhpParser\Node\Identifier;
use PhpParser\Node\Name;
use PhpParser\Node\NullableType;
use PhpParser\Node\Param;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Property;
use PhpParser\Node\Stmt\Return_;
use PhpParser\NodeAbstract;
use PhpParser\NodeFinder;
use PhpParser\ParserFactory;
use PHPStan\PhpDocParser\Ast\PhpDoc\ParamTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTextNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\ReturnTagValueNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayShapeNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayTypeNode;
use PHPStan\PhpDocParser\Ast\Type\GenericTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IntersectionTypeNode;
use PHPStan\PhpDocParser\Ast\Type\NullableTypeNode;
use PHPStan\PhpDocParser\Ast\Type\TypeNode;
use PHPStan\PhpDocParser\Ast\Type\UnionTypeNode;
use PHPStan\PhpDocParser\Lexer\Lexer;
use PHPStan\PhpDocParser\Parser\ConstExprParser;
use PHPStan\PhpDocParser\Parser\PhpDocParser;
use PHPStan\PhpDocParser\Parser\TokenIterator;
use PHPStan\PhpDocParser\Parser\TypeParser;

$command = new Command("openapi-extractor", "Extract OpenAPI specs from the Nextcloud source code");
$command
	->arguments("dir out")
	->parse($_SERVER["argv"]);

$dir = $command->dir;
$out = $command->out;

if ($dir == "") {
	$dir = ".";
}
if ($out == "") {
	$out = "openapi.json";
}

$astParser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);
$nodeFinder = new NodeFinder;

$lexer = new Lexer();
$constExprParser = new ConstExprParser();
$typeParser = new TypeParser($constExprParser);
$phpDocParser = new PhpDocParser($typeParser, $constExprParser);

$infoXMLPath = join("/", [$dir, "appinfo", "info.xml"]);

if (file_exists($infoXMLPath)) {
	$xml = simplexml_load_file($infoXMLPath) or die("Unable to read or parse " . $infoXMLPath . "\n");

	$appIsCore = false;
	$appID = (string)$xml->id;
	$appName = (string)$xml->name;
	$appSummary = (string)$xml->summary;
	$appVersion = (string)$xml->version;
	$appLicence = (string)$xml->licence;
} else {
	$versionPHPPath = join("/", [$dir, "..", "version.php"]);

	if (!file_exists($versionPHPPath)) {
		die("Neither " . $infoXMLPath . " nor " . $versionPHPPath . " exists\n");
	}

	// Includes https://github.com/nextcloud/server/blob/master/version.php when running inside https://github.com/nextcloud/server/tree/master/core
	include(join("/", [$dir, "..", "version.php"]));
	if (!isset($OC_VersionString)) {
		die("Unable to figure out core version\n");
	}

	$appIsCore = true;
	$appID = "core";
	$appName = "Core";
	$appSummary = "Core functionality of Nextcloud";
	$appVersion = $OC_VersionString;
	$appLicence = "agpl";
}

$openapi = new OpenApi([
	"openapi" => "3.0.3",
	"info" => new Info([
		"title" => $appName,
		"version" => $appVersion,
		"description" => $appSummary,
		"license" => [
			"name" => $appLicence,
		],
	]),
	"security" => [
		new SecurityRequirement([
			"basic_auth" => [],
		]),
	],
	"components" => [
		"securitySchemes" => [
			"basic_auth" => [
				"type" => "http",
				"scheme" => "basic",
			]
		],
		"schemas" => [],
	],
	"tags" => [
		[
			"name" => $appID,
		]
	],
	"paths" => [],
]);

$schemas = [];

print_r("Extracting OpenAPI spec for " . $appName . " " . $appVersion . "\n");

$routes = parseRoutes(join("/", $appIsCore ? [$dir, "routes.php"] : [$dir, "appinfo", "routes.php"]));

$seenRouteNames = [];

foreach ($routes as $key => $value) {
	foreach ($value as $route) {
		$routeName = $route["name"];
		if (str_starts_with(strtolower($routeName), "page#") || str_starts_with(strtolower($routeName), "admin#") || in_array($routeName, $seenRouteNames)) {
			continue;
		}
		$seenRouteNames[] = $routeName;

		$verb = array_key_exists("verb", $route) ? $route["verb"] : "GET";
		$requirements = array_key_exists("requirements", $route) ? $route["requirements"] : [];
		$root = array_key_exists("root", $route) ? $route["root"] : ($appIsCore ? "" : "/apps") . "/" . $appID;
		$url = $route["url"];
		if (!str_starts_with($url, "/")) {
			$url = "/" . $url;
		}
		if (str_ends_with($url, "/")) {
			$url = substr($url, 0, -1);
		}
		if ($key == "routes") {
			$url = "/index.php" . $root . $url;
		}
		if ($key == "ocs") {
			$url = "/ocs/v2.php" . $root . $url;
		}

		$methodName = lcfirst(str_replace("_", "", ucwords(explode("#", $routeName)[1], "_")));
		if ($methodName == "preflightedCors") {
			continue;
		}

		$controllerName = ucfirst(str_replace("_", "", ucwords(explode("#", $routeName)[0], "_")));

		$methodFunction = findControllerMethod(join("/", $appIsCore ? [$dir, "Controller", $controllerName . "Controller.php"] : [$dir, "lib", "Controller", $controllerName . "Controller.php"]), $controllerName, $methodName);
		if ($methodFunction == null) {
			print_r("Warning " . $routeName . " is ignored\n");
			continue;
		}

		$classMethodInfo = extractMethodInfo($methodFunction);
		if (count($classMethodInfo->returns) > 0) {
			die($routeName . " can not return something that is not a valid response.\n");
		}

		$codeStatusCodes = [];
		/* @var $returnStatement Return_ */
		foreach ($nodeFinder->findInstanceOf($methodFunction->stmts, Return_::class) as $returnStatement) {
			if ($returnStatement->expr instanceof New_) {
				if ($returnStatement->expr->class instanceof Name) {
					$type = $returnStatement->expr->class->getLast();
					if ($type == "DataResponse" || $type == "JSONResponse") {
						$statusCode = 200;
						if (count($returnStatement->expr->args) > 1) {
							if (!($returnStatement->expr->args[1]->value instanceof ClassConstFetch)) {
								print_r("Warning " . $routeName . " contains a return statement that can not be evaluated\n");
								continue;
							}
							$name = $returnStatement->expr->args[1]->value->name;
							if (!($name instanceof Identifier)) {
								print_r("Warning " . $routeName . " contains a return statement that can not be evaluated\n");
								continue;
							}
							$statusCode = match ($name->name) {
								"STATUS_OK" => 200,
								"STATUS_CREATED" => 201,
								"STATUS_ACCEPTED" => 202,
								"STATUS_NO_CONTENT" => 204,
								"STATUS_NOT_MODIFIED" => 304,
								"STATUS_BAD_REQUEST" => 400,
								"STATUS_UNAUTHORIZED" => 401,
								"STATUS_FORBIDDEN" => 403,
								"STATUS_NOT_FOUND" => 404,
								"STATUS_METHOD_NOT_ALLOWED" => 405,
								"STATUS_NOT_ACCEPTABLE" => 406,
								"STATUS_CONFLICT" => 409,
								"STATUS_PRECONDITION_FAILED" => 412,
								"STATUS_REQUEST_ENTITY_TOO_LARGE" => 413,
								"STATUS_INTERNAL_SERVER_ERROR" => 500,
								"STATUS_NOT_IMPLEMENTED" => 501,
								default => die("Unknown status code " . $name->name . "\n"),
							};
						}

						$codeStatusCodes[] = $statusCode;
					}
				}
			}
		}

		$docStatusCodes = array_map(function (ClassMethodResponse $response) {
			return $response->statusCode;
		}, $classMethodInfo->responses);
		$missingDocStatusCodes = array_diff($codeStatusCodes, $docStatusCodes);
		$missingCodeStatusCodes = array_diff($docStatusCodes, $codeStatusCodes);

		if (count($missingDocStatusCodes) > 0) {
			print_r("Warning " . $routeName . " returns the following undocumented status codes: " . implode(", ", $missingDocStatusCodes) . "\n");
		}
		if (count($missingCodeStatusCodes) > 0) {
			print_r("Warning " . $routeName . " documents the following status codes which are never returned: " . implode(", ", $missingCodeStatusCodes) . "\n");
		}

		$pathParameters = [];
		$urlParameters = [];

		preg_match_all("/{[^}]*}/", $url, $urlParameters);
		$urlParameters = array_map(function (string $name) {
			return substr($name, 1, -1);
		}, $urlParameters[0]);

		if (!$openapi->paths->hasPath($url)) {
			foreach ($urlParameters as $urlParameter) {
				$matchingParameters = array_filter($classMethodInfo->parameters, function (ClassMethodParameter $param) use ($urlParameter) {
					return $param->name == $urlParameter;
				});
				if (count($matchingParameters) == 1) {
					$parameter = $matchingParameters[0];
					if ($parameter?->methodParameter == null && ($requirements == null || !array_key_exists($urlParameter, $requirements))) {
						die("Unable to find parameter for " . $urlParameter . " in " . $routeName . "\n");
					}

					$pathParameters[] = new Parameter(array_merge(
						[
							"name" => $urlParameter,
							"in" => "path",
							"required" => true,
							"schema" => $parameter->type->toSchema(),
						],
						$parameter?->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
					));
				} else {
					$requirement = array_key_exists($urlParameter, $requirements) ? $requirements[$urlParameter] : null;
					if ($requirement != null) {
						if (!str_starts_with($requirement, "^")) {
							$requirement = "^" . $requirement;
						}
						if (!str_ends_with($requirement, "$")) {
							$requirement = $requirement . "$";
						}
					}
					$pathParameters[] = new Parameter(array_merge(
						[
							"name" => $urlParameter,
							"in" => "path",
							"required" => true,
							"schema" => array_merge(
								$requirement != null ? [
									"type" => "string",
									"pattern" => $requirement,
								] : [],
							),
						],
					));
				}
			}

			$openapi->paths->addPath(
				$url,
				new PathItem([
					"parameters" => $pathParameters,
				]),
			);
		} else {
			$pathParameters = $openapi->paths->getPath($url)->parameters;
		}

		$queryParameters = [];
		foreach ($classMethodInfo->parameters as $parameter) {
			$alreadyInPath = false;
			foreach ($pathParameters as $pathParameter) {
				if ($pathParameter->name == $parameter->name) {
					$alreadyInPath = true;
					break;
				}
			}
			if (!$alreadyInPath) {
				$queryParameters[] = $parameter;
			}
		}

		$responses = [];
		foreach ($classMethodInfo->responses as $response) {
			$responses[$response->statusCode] = new Response(
				array_merge(
					[
						"content" => [
							$response->contentType => new MediaType([
								"schema" => $response->type->toSchema(),
							]),
						],
					],
					$response->description != null ? ["description" => $response->description] : [],
				),
			);
		}

		$operation = new Operation(array_merge([
			"operationId" => generateOperationID($methodName, $controllerName),
			"tags" => [$appID],
			"responses" => $responses,
			"description" => implode("\n", $classMethodInfo->description),
		],
			$classMethodInfo->summary != null ? ["summary" => $classMethodInfo->summary] : [],
			count($queryParameters) > 0 ? [
				"parameters" => array_map(function (ClassMethodParameter $parameter) {
					return new Parameter(array_merge(
						[
							"name" => $parameter->name,
							"in" => "query",
							"schema" => $parameter->type->toSchema(true),
						],
						!$parameter->type->nullable ? ["required" => true] : [],
						$parameter->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
					));
				}, $queryParameters),
			] : []),
		);
		switch ($verb) {
			case "DELETE":
				$openapi->paths->getPath($url)->delete = $operation;
				break;
			case "GET":
				$openapi->paths->getPath($url)->get = $operation;
				break;
			case "POST":
				$openapi->paths->getPath($url)->post = $operation;
				break;
			case "PUT":
				$openapi->paths->getPath($url)->put = $operation;
				break;
			case "PATCH":
				$openapi->paths->getPath($url)->patch = $operation;
				break;
			case "OPTIONS":
				$openapi->paths->getPath($url)->options = $operation;
				break;
		}
	}
}

$openapi->components->schemas = $schemas;

file_put_contents($out, Writer::writeToJson($openapi, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));
if (!$openapi->validate()) {
	die("Invalid OpenAPI spec generated. Please review the output!\n");
}

function extractMethodInfo(ClassMethod $method): ClassMethodInfo
{
	global $phpDocParser, $lexer;

	$parameters = [];
	$responses = [];
	$returns = [];

	$methodDescription = [];
	$methodSummary = null;
	$methodParameters = $method->getParams();
	$docParameters = [];

	$doc = $method->getDocComment()?->getText();
	if ($doc != null) {
		$docNodes = $phpDocParser->parse(new TokenIterator($lexer->tokenize($doc)))->children;
		foreach ($docNodes as $docNode) {
			if ($docNode instanceof PhpDocTextNode) {
				$line = cleanDocComment($docNode->text);
				if ($line == "") {
					continue;
				}
				$methodDescription[] = $line;
			}

			if ($docNode instanceof PhpDocTagNode) {
				if ($docNode->value instanceof ParamTagValueNode) {
					$docParameters[] = $docNode->value;
				}

				if ($docNode->value instanceof ReturnTagValueNode) {
					$type = $docNode->value->type;

					if ($type instanceof GenericTypeNode && ($type->type->name == "JSONResponse" || $type->type->name == "DataResponse")) {
						preg_match("/^([0-9]{3})((?: .*)?)$/", $docNode->value->description, $matches);
						if (count($matches) != 3) {
							die("Unable to figure out status code and description for return type '" . $docNode . "'\n");
						}
						$statusCode = $matches[1];
						$description = ltrim($matches[2], ' ');

						$contentType = match ($type->type->name) {
							"JSONResponse" => "application/json",
						};

						$realType = resolveOpenApiType($type->genericTypes[0]);

						if (array_key_exists($statusCode, $responses)) {
							die("Multiple return annotations for the same status code not allowed in '" . $method->name . "'\n");
						}

						$responses[$statusCode] = new ClassMethodResponse($statusCode, $contentType, $realType, $description != "" ? $description : null);
					} else {
						$returns[] = resolveOpenApiType($type);
					}
				}
			}
		}
	}

	foreach ($methodParameters as $methodParameter) {
		$param = null;
		$methodParameterName = $methodParameter->var->name;

		foreach ($docParameters as $docParameter) {
			$docParameterName = substr($docParameter->parameterName, 1);

			if ($docParameterName == $methodParameterName) {
				$param = new ClassMethodParameter($methodParameterName, $methodParameter, $docParameter);
				break;
			}
		}

		if ($param == null) {
			$param = new ClassMethodParameter($methodParameterName, $methodParameter, null);
		}

		$parameters[] = $param;
	}

	if (count($methodDescription) > 1) {
		$methodSummary = $methodDescription[0];
		$methodDescription = array_slice($methodDescription, 1);
	}

	return new ClassMethodInfo($parameters, array_values($responses), $returns, $methodDescription, $methodSummary);
}

class ClassMethodInfo
{
	/**
	 * @param ClassMethodParameter[] $parameters
	 * @param ClassMethodResponse[] $responses
	 * @param OpenApiType[] $returns
	 * @param string[] $description
	 */
	public function __construct(public array $parameters, public array $responses, public array $returns, public array $description, public ?string $summary)
	{
	}
}

class ClassMethodResponse
{
	public function __construct(public int $statusCode, public string $contentType, public OpenApiType $type, public ?string $description)
	{
	}

}

class ClassMethodParameter
{
	public OpenApiType $type;

	public int $flags;

	public function __construct(public string $name, public Param $methodParameter, public ?PhpDocTagValueNode $docParameter)
	{
		if ($docParameter != null) {
			$this->type = resolveOpenApiType($docParameter->type);
		} else {
			$this->type = resolveOpenApiType($methodParameter->type);
		}
		$this->type->defaultValue = exprToString($methodParameter->default);
		$this->flags = $this->methodParameter->flags;
	}
}

function exprToString(null|Expr $expr): mixed
{
	if ($expr == null) {
		return null;
	}
	if ($expr instanceof ConstFetch) {
		$value = $expr->name->getLast();
		switch ($value) {
			case "null":
				return null;
			case "true":
				return true;
			case "false":
				return false;
			default:
				die("Unable to convert ConstFetch " . $value . "\n");
		}
	}
	if ($expr instanceof String_) {
		return $expr->value;
	}
	if ($expr instanceof LNumber) {
		return intval($expr->value);
	}
	if ($expr instanceof UnaryMinus) {
		return exprToString($expr->expr);
	}
	if ($expr instanceof Array_) {
		return array_map(function (ArrayItem $item) {
			return exprToString($item);
		}, $expr->items);
	}

	die("Unable to convert Expr " . get_class($expr) . "\n");
}

function resolveIdentifier(string $name): OpenApiType
{
	global $openapi, $schemas, $dir;
	return match ($name) {
		"string" => new OpenApiType(type: "string", nullable: false),
		"int", "integer" => new OpenApiType(type: "integer", nullable: false),
		"bool", "boolean" => new OpenApiType(type: "boolean", nullable: false),
		"double" => new OpenApiType(type: "number", format: "double", nullable: false),
		"float" => new OpenApiType(type: "number", format: "float", nullable: false),
		"array" => new OpenApiType(type: "array", nullable: false),
		"null" => new OpenApiType(nullable: true),
		default => (function () use ($dir, &$schemas, $openapi, $name) {
			// TODO: This name resolution isn't great, but works for now.
			$class = loadClass(join("/", [$dir, "lib", "Model", "Response", $name . ".php"]), $name);
			if ($class != null) {
				$implementsJsonSerializable = false;
				foreach ($class->implements as $implement) {
					if ($implement->getLast() == "JsonSerializable") {
						$implementsJsonSerializable = true;
					}
				}
				if (!$implementsJsonSerializable) {
					die("'" . $name . "' does not implement JsonSerializable\n");
				}
				if (!array_key_exists($name, $schemas)) {
					$schemas[$name] = resolveOpenApiType($class)->toSchema();
				}
				return new OpenApiType(
					ref: "#/components/schemas/" . $name,
				);
			}
			die("Unable to resolve OpenAPI type for identifier '" . $name . "'\n");
		})(),
	};
}

function resolveOpenApiType(Class_|NodeAbstract|TypeNode $node): OpenApiType
{
	if ($node instanceof PhpParser\Node\Name) {
		return resolveIdentifier($node->getLast());
	}
	if ($node instanceof IdentifierTypeNode || $node instanceof Identifier) {
		return resolveIdentifier($node->name);
	}

	if ($node instanceof ArrayTypeNode) {
		return new OpenApiType(type: "array", nullable: false, items: resolveOpenApiType($node->type));
	}

	if ($node instanceof ArrayShapeNode) {
		$properties = [];
		$required = [];
		foreach ($node->items as $item) {
			$type = resolveOpenApiType($item->valueType);
			$properties[$item->keyName->name] = $type;
			if (!$type->nullable) {
				$required[] = $item->keyName->name;
			}
		}
		return new OpenApiType(type: "object", nullable: false, properties: count($properties) > 0 ? $properties : null, additionalProperties: count($properties) == 0 ? true : null, required: count($required) > 0 ? $required : null);
	}

	if ($node instanceof NullableTypeNode || $node instanceof NullableType) {
		$type = resolveOpenApiType($node->type);
		$type->nullable = true;
		return $type;
	}

	if ($node instanceof UnionTypeNode || $node instanceof IntersectionTypeNode) {
		$nullable = false;
		$types = [];
		foreach ($node->types as $type) {
			if ($type instanceof IdentifierTypeNode && $type->name == "null") {
				$nullable = true;
			} else {
				$types[] = $type;
			}
		}

		if (count($types) == 1) {
			$type = resolveOpenApiType($types[0]);
			$type->nullable = true;
			return $type;
		} else {
			return new OpenApiType(
				nullable: $nullable,
				anyOf: $node instanceof UnionTypeNode ? $types : null,
				allOf: $node instanceof IntersectionTypeNode ? $types : null,
			);
		}
	}

	if ($node instanceof Class_) {
		if (count(array_filter($node->stmts, function ($stmt) {
				return $stmt instanceof Property;
			})) > 0) {
			die("Model '" . $node->name->name . "' is not allowed to have properties. Fields can only be declared in the constructor.\n");
		}
		$properties = [];
		$required = [];
		foreach ($node->stmts as $stmt) {
			if (!$stmt instanceof ClassMethod || $stmt->name != "__construct") {
				continue;
			}

			$classMethodInfo = extractMethodInfo($stmt);
			foreach ($classMethodInfo->parameters as $parameter) {
				if ($parameter->flags == 0) {
					// Disallow non-protected parameters since they are from extended classes
					continue;
				}
				if ($parameter->flags != Class_::MODIFIER_PROTECTED) {
					die("Parameter '" . $parameter->name . "' of Model '" . $node->name->name . "' has a field that is not protected.\n");
				}
				$properties[$parameter->name] = $parameter->type;
				if (!$parameter->type->nullable) {
					$required[] = $parameter->name;
				}
			}
		}

		$type = new OpenApiType(type: "object", nullable: false, properties: $properties, required: $required);
		if ($node->extends != null) {
			return new OpenApiType(allOf: [
				resolveOpenApiType($node->extends),
				$type,
			]);
		}
		return $type;
	}

	die("Unable to resolve OpenAPI type for type '" . get_class($node) . "'\n");
}

class OpenApiType
{

	public ?string $ref;
	public ?string $type;

	public ?string $format;

	public ?bool $nullable;

	public mixed $defaultValue;

	public ?OpenApiType $items;

	public ?array $properties;

	/** @var OpenApiType[]|null */
	public ?array $anyOf;

	/** @var OpenApiType[]|null */
	public ?array $allOf;

	public ?bool $additionalProperties;

	public ?array $required;

	public ?string $description;

	public function __construct(?string $ref = null, ?string $type = null, ?string $format = null, ?bool $nullable = null, mixed $defaultValue = null, ?OpenApiType $items = null, ?array $properties = null, ?array $anyOf = null, ?array $allOf = null, ?bool $additionalProperties = null, ?array $required = null, ?string $description = null)
	{
		$this->ref = $ref;
		$this->type = $type;
		$this->format = $format;
		$this->nullable = $nullable;
		$this->defaultValue = $defaultValue;
		$this->items = $items;
		$this->properties = $properties;
		$this->anyOf = $anyOf;
		$this->allOf = $allOf;
		$this->additionalProperties = $additionalProperties;
		$this->required = $required;
		$this->description = $description;
	}

	public function toSchema(bool $booleanQuirk = false): Schema
	{
		return new Schema(array_merge(
			$this->ref != null ? ["\$ref" => $this->ref] : [],
			$this->type != null ? ["type" => $booleanQuirk && $this->type == "boolean" ? "integer" : $this->type] : [],
			$this->format != null ? ["format" => $this->format] : [],
			$this->defaultValue != null ? ["default" => $booleanQuirk && $this->type == "boolean" ? $this->defaultValue == "true" ? 1 : 0 : $this->defaultValue] : [],
			$this->items != null ? ["items" => $this->items->toSchema($booleanQuirk)] : [],
			$this->properties != null ? ["properties" =>
				array_combine(array_keys($this->properties),
					array_map(function (OpenApiType $property) use ($booleanQuirk) {
						return $property->toSchema($booleanQuirk);
					}, array_values($this->properties)),
				)] : [],
			$this->anyOf != null ? ["anyOf" => array_map(function (OpenApiType $type) use ($booleanQuirk) {
				return $type->toSchema($booleanQuirk);
			}, $this->anyOf)] : [],
			$this->allOf != null ? ["allOf" => array_map(function (OpenApiType $type) use ($booleanQuirk) {
				return $type->toSchema($booleanQuirk);
			}, $this->allOf)] : [],
			$this->additionalProperties != null ? ["additionalProperties" => $this->additionalProperties] : [],
			$this->required != null && count($this->required) > 0 ? ["required" => $this->required] : [],
			$this->description != null && $this->description != "" ? ["description" => $this->description] : [],
		));
	}
}

function findControllerMethod(string $filename, string $controllerName, string $methodName): ?ClassMethod
{
	$class = loadClass($filename, $controllerName . "Controller");
	if ($class != null) {
		foreach ($class->stmts as $node) {
			if ($node instanceof ClassMethod) {
				if ($node->name == $methodName) {
					$doc = $node->getDocComment()?->getText();
					if ($class->extends != "Controller" || ($doc != null && str_contains($doc, "@NoCSRFRequired"))) {
						return $node;
					} else {
						return null;
					}
				}
			}
		}
	}

	return null;
}

function loadClass(string $filename, string $name): ?Class_
{
	global $astParser;
	$content = file_get_contents($filename);
	$ast = $astParser->parse($content);
	return findClass($ast, $name);
}

function findClass(array $ast, string $className): ?Class_
{
	global $nodeFinder;
	/** @var Class_ $class */
	foreach ($nodeFinder->findInstanceOf($ast, Class_::class) as $class) {
		if ($class->name == $className) {
			return $class;
		}
	}

	return null;
}

function parseRoutes(string $path): array
{
	$content = file_get_contents($path);
	if (str_contains($content, "return ")) {
		return include($path);
	} elseif (str_contains($content, "registerRoutes")) {
		preg_match("/registerRoutes\(\\\$this, (\[[^;]*)\);/", $content, $matches);

		$tmpPath = tempnam(sys_get_temp_dir(), "routes-");
		file_put_contents($tmpPath, "<?php\nreturn " . $matches[1] . ";");
		$routes = include($tmpPath);
		unlink($tmpPath);

		return $routes;
	} else {
		die("Unknown routes.php format\n");
	}
}

function cleanDocComment(string $comment): string
{
	return trim(preg_replace("/\s+/", " ", $comment));
}

function splitOnUppercaseFollowedByNonUppercase(string $str): array
{
	return preg_split('/(?=[A-Z][^A-Z])/', $str, -1, PREG_SPLIT_NO_EMPTY);
}

function generateOperationID(string $methodName, string $controllerName): string
{
	$verbParts = array_map(function (string $verbPart) {
		return strtolower($verbPart);
	}, splitOnUppercaseFollowedByNonUppercase($methodName));
	$verb = mapVerb(implode("-", $verbParts));

	$objectParts = array_filter(array_map(function (string $objectPart) {
		return strtolower($objectPart);
	}, splitOnUppercaseFollowedByNonUppercase($controllerName)), function (string $objectPart) {
		return !in_array($objectPart, ["api", "endpoint", "request", "handler"]);
	});
	$object = implode("-", $objectParts);

	if (array_intersect($objectParts, $verbParts) == $objectParts || $object == "") {
		return $verb;
	}
	if (array_intersect($verbParts, $objectParts) == $verbParts) {
		return $object;
	}

	if (count($verbParts) == 1) {
		// Make it plural when listing
		if ($verb == "list" && !str_ends_with($object, "s")) {
			$object .= "s";
		}

		return "$verb-$object";
	}

	return "$object-$verb";
}

function mapVerb(string $verb): string
{
	return match ($verb) {
		"index" => "list",
		default => $verb,
	};
}