#!/usr/bin/env php
<?php

require_once __DIR__ . "/vendor/autoload.php";

use Ahc\Cli\Input\Command;
use cebe\openapi\spec\Info;
use cebe\openapi\spec\MediaType;
use cebe\openapi\spec\OpenApi;
use cebe\openapi\spec\Operation;
use cebe\openapi\spec\Parameter;
use cebe\openapi\spec\PathItem;
use cebe\openapi\spec\Response;
use cebe\openapi\spec\Schema;
use cebe\openapi\spec\SecurityRequirement;
use cebe\openapi\Writer;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Expr\UnaryMinus;
use PhpParser\Node\Param;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Namespace_;
use PhpParser\ParserFactory;
use PHPStan\PhpDocParser\Ast\PhpDoc\ParamTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTextNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayShapeNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IntersectionTypeNode;
use PHPStan\PhpDocParser\Ast\Type\NullableTypeNode;
use PHPStan\PhpDocParser\Ast\Type\TypeNode;
use PHPStan\PhpDocParser\Ast\Type\UnionTypeNode;
use PHPStan\PhpDocParser\Lexer\Lexer;
use PHPStan\PhpDocParser\Parser\ConstExprParser;
use PHPStan\PhpDocParser\Parser\PhpDocParser;
use PHPStan\PhpDocParser\Parser\TokenIterator;
use PHPStan\PhpDocParser\Parser\TypeParser;

$command = new Command("openapi-extractor", "Extract OpenAPI specs from the Nextcloud source code");
$command
	->arguments("dir out")
	->parse($_SERVER["argv"]);

$dir = $command->dir;
$out = $command->out;

if ($dir == "") {
	$dir = ".";
}
if ($out == "") {
	$out = "openapi.json";
}

$astParser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);

$lexer = new Lexer();
$constExprParser = new ConstExprParser();
$typeParser = new TypeParser($constExprParser);
$phpDocParser = new PhpDocParser($typeParser, $constExprParser);

$infoXMLPath = join("/", [$dir, "appinfo", "info.xml"]);

if (file_exists($infoXMLPath)) {
	$xml = simplexml_load_file($infoXMLPath) or die("Unable to read or parse " . $infoXMLPath . "\n");

	$appIsCore = false;
	$appID = (string)$xml->id;
	$appName = (string)$xml->name;
	$appSummary = (string)$xml->summary;
	$appVersion = (string)$xml->version;
	$appLicence = (string)$xml->licence;
} else {
	$versionPHPPath = join("/", [$dir, "..", "version.php"]);

	if (!file_exists($versionPHPPath)) {
		die("Neither " . $infoXMLPath . " nor " . $versionPHPPath . " exists\n");
	}

	// Includes https://github.com/nextcloud/server/blob/master/version.php when running inside https://github.com/nextcloud/server/tree/master/core
	include(join("/", [$dir, "..", "version.php"]));
	if (!isset($OC_VersionString)) {
		die("Unable to figure out core version\n");
	}

	$appIsCore = true;
	$appID = "core";
	$appName = "Core";
	$appSummary = "Core functionality of Nextcloud";
	$appVersion = $OC_VersionString;
	$appLicence = "agpl";
}

$openapi = new OpenApi([
	"openapi" => "3.0.3",
	"info" => new Info([
		"title" => $appName,
		"version" => $appVersion,
		"description" => $appSummary,
		"license" => [
			"name" => $appLicence,
		],
	]),
	"security" => [
		new SecurityRequirement([
			"basic_auth" => [],
		]),
	],
	"components" => [
		"securitySchemes" => [
			"basic_auth" => [
				"type" => "http",
				"scheme" => "basic",
			]
		],
	],
	"tags" => [
		[
			"name" => $appID,
		]
	],
	"paths" => [],
]);

print_r("Extracting OpenAPI spec for " . $appName . " " . $appVersion . "\n");

$routes = parseRoutes(join("/", $appIsCore ? [$dir, "routes.php"] : [$dir, "appinfo", "routes.php"]));

$seenRouteNames = [];

foreach ($routes as $key => $value) {
	foreach ($value as $route) {
		$name = $route["name"];
		if (str_starts_with(strtolower($name), "page#") || str_starts_with(strtolower($name), "admin#") || in_array($name, $seenRouteNames)) {
			continue;
		}
		$seenRouteNames[] = $name;

		$verb = array_key_exists("verb", $route) ? $route["verb"] : "GET";
		$requirements = array_key_exists("requirements", $route) ? $route["requirements"] : [];
		$root = array_key_exists("root", $route) ? $route["root"] : ($appIsCore ? "" : "/apps") . "/" . $appID;
		$url = $route["url"];
		if (!str_starts_with($url, "/")) {
			$url = "/" . $url;
		}
		if (str_ends_with($url, "/")) {
			$url = substr($url, 0, -1);
		}
		if ($key == "routes") {
			$url = "/index.php" . $root . $url;
		}
		if ($key == "ocs") {
			$url = "/ocs/v2.php" . $root . $url;
		}

		$methodName = lcfirst(str_replace("_", "", ucwords(explode("#", $name)[1], "_")));
		if ($methodName == "preflightedCors") {
			continue;
		}

		$controllerName = ucfirst(str_replace("_", "", ucwords(explode("#", $name)[0], "_")));

		$controllerContent = file_get_contents(join("/", $appIsCore ? [$dir, "Controller", $controllerName . "Controller.php"] : [$dir, "lib", "Controller", $controllerName . "Controller.php"]));
		$ast = $astParser->parse($controllerContent);

		$methodFunction = findMethod($ast, $controllerName, $methodName);
		if ($methodFunction == null) {
			continue;
		}

		$methodDescription = [];
		$methodParameters = $methodFunction->getParams();
		$urlParameters = [];
		$docParameters = [];

		preg_match_all("/{[^}]*}/", $url, $urlParameters);
		$urlParameters = array_map(function (string $name) {
			return substr($name, 1, -1);
		}, $urlParameters[0]);

		$doc = $methodFunction->getDocComment()?->getText();
		if ($doc != null) {
			$docNodes = $phpDocParser->parse(new TokenIterator($lexer->tokenize($doc)))->children;
			foreach ($docNodes as $docNode) {
				if ($docNode instanceof PhpDocTextNode) {
					$line = cleanDocComment($docNode->text);
					if ($line == "") {
						continue;
					}
					$methodDescription[] = $line;
				}

				if ($docNode instanceof PhpDocTagNode) {
					if ($docNode->value instanceof ParamTagValueNode) {
						$docParameters[] = $docNode->value;
					}
				}
			}
		}

		$parameters = [];
		foreach ($methodParameters as $methodParameter) {
			$parameters[$methodParameter->var->name] = new RequestParameter($methodParameter->var->name, $methodParameter, null);
		}
		foreach ($docParameters as $docParameter) {
			$name = substr($docParameter->parameterName, 1);
			if (!array_key_exists($name, $parameters)) {
				$parameters[$name] = new RequestParameter($name, null, $docParameter);
			} else {
				$parameters[$name] = new RequestParameter($name, $parameters[$name]->methodParameter, $docParameter);
			}
		}

		$pathParameters = [];
		if (!$openapi->paths->hasPath($url)) {
			foreach ($urlParameters as $urlParameter) {
				if (array_key_exists($urlParameter, $parameters)) {
					$parameter = $parameters[$urlParameter];
					if ($parameter?->methodParameter == null && ($requirements == null || !array_key_exists($urlParameter, $requirements))) {
						die("Unable to find parameter for " . $urlParameter . " in " . $url . "\n");
					}

					$pathParameters[] = new Parameter(array_merge(
						[
							"name" => $urlParameter,
							"in" => "path",
							"required" => true,
							"schema" => $parameter->type->toSchema(false),
						],
						$parameter?->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
					));
				} else {
					$requirement = array_key_exists($urlParameter, $requirements) ? $requirements[$urlParameter] : null;
					if ($requirement != null) {
						if (!str_starts_with($requirement, "^")) {
							$requirement = "^" . $requirement;
						}
						if (!str_ends_with($requirement, "$")) {
							$requirement = $requirement . "$";
						}
					}
					$pathParameters[] = new Parameter(array_merge(
						[
							"name" => $urlParameter,
							"in" => "path",
							"required" => true,
							"schema" => array_merge(
								$requirement != null ? [
									"type" => "string",
									"pattern" => $requirement,
								] : [],
							),
						],
					));
				}
			}

			$openapi->paths->addPath(
				$url,
				new PathItem([
					"parameters" => $pathParameters,
				]),
			);
		} else {
			$pathParameters = $openapi->paths->getPath($url)->parameters;
		}

		$queryParameters = [];
		foreach ($parameters as $parameter) {
			$alreadyInPath = false;
			foreach ($pathParameters as $pathParameter) {
				if ($pathParameter->name == $parameter->name) {
					$alreadyInPath = true;
					break;
				}
			}
			if (!$alreadyInPath) {
				$queryParameters[] = $parameter;
			}
		}

		$operation = new Operation([
			"operationId" => generateOperationID($methodName, $controllerName),
			"tags" => [$appID],
			"responses" => [
				"200" => new Response([
					"description" => "",
					"content" => [
						"application/json" => new MediaType([
							"schema" => new Schema([
								"type" => "string",
							]),
						]),
					],
				]),
			],
			"parameters" => array_map(function (RequestParameter $parameter) {
				return new Parameter(array_merge(
					[
						"name" => $parameter->name,
						"in" => "query",
					],
					$parameter->type != null ? array_merge(
						["schema" => $parameter->type->toSchema(true)],
						!$parameter->type->nullable ? ["required" => true] : [],
					) : [],
					$parameter->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
				));
			}, $queryParameters),
		]);
		switch ($verb) {
			case "DELETE":
				$openapi->paths->getPath($url)->delete = $operation;
				break;
			case "GET":
				$openapi->paths->getPath($url)->get = $operation;
				break;
			case "POST":
				$openapi->paths->getPath($url)->post = $operation;
				break;
			case "PUT":
				$openapi->paths->getPath($url)->put = $operation;
				break;
			case "PATCH":
				$openapi->paths->getPath($url)->patch = $operation;
				break;
			case "OPTIONS":
				$openapi->paths->getPath($url)->options = $operation;
				break;
		}
	}
}

file_put_contents($out, Writer::writeToJson($openapi, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));
if (!$openapi->validate()) {
	die("Invalid OpenAPI spec generated. Please review the output!\n");
}


class RequestParameter
{
	public string $name;

	public ?Param $methodParameter;

	public ?PhpDocTagValueNode $docParameter;

	public ?OpenApiType $type;

	public function __construct(string $name, ?Param $methodParameter, ?PhpDocTagValueNode $docParameter)
	{
		$this->name = $name;
		$this->methodParameter = $methodParameter;
		$this->docParameter = $docParameter;

		if ($docParameter != null) {
			$this->type = resolveOpenApiType($docParameter->type);

			if ($methodParameter != null) {
				$this->type->defaultValue = exprToString($methodParameter->default);
			}
		}
	}
}

function exprToString(null|Expr $expr): mixed
{
	if ($expr == null) {
		return null;
	}
	if ($expr instanceof ConstFetch) {
		$value = $expr->name->getLast();
		switch ($value) {
			case "null":
				return null;
			case "true":
				return true;
			case "false":
				return false;
			default:
				die("Unable to convert ConstFetch " . $value . "\n");
		}
	}
	if ($expr instanceof String_) {
		return $expr->value;
	}
	if ($expr instanceof LNumber) {
		return intval($expr->value);
	}
	if ($expr instanceof UnaryMinus) {
		return exprToString($expr->expr);
	}
	if ($expr instanceof Array_) {
		return array_map(function (ArrayItem $item) {
			return exprToString($item);
		}, $expr->items);
	}

	die("Unable to convert Expr " . get_class($expr) . "\n");
}

function resolveOpenApiType(TypeNode $node): OpenApiType
{
	if ($node instanceof IdentifierTypeNode) {
		return match ($node->name) {
			"string" => new OpenApiType("string", nullable: false),
			"int", "integer" => new OpenApiType("integer", nullable: false),
			"bool", "boolean" => new OpenApiType("boolean", nullable: false),
			"double" => new OpenApiType("number", "double", nullable: false),
			"float" => new OpenApiType("number", "float", nullable: false),
			"array" => new OpenApiType("array", nullable: false),
			"null" => new OpenApiType(nullable: true),
			default => die("Unable to resolve OpenAPI type for " . $node->name . "\n"),
		};
	}

	if ($node instanceof ArrayTypeNode) {
		return new OpenApiType("array", nullable: false, items: resolveOpenApiType($node->type));
	}

	if ($node instanceof ArrayShapeNode) {
		$properties = [];
		foreach ($node->items as $item) {
			$properties[$item->keyName->name] = resolveOpenApiType($item->valueType);
		}
		return new OpenApiType("object", nullable: false, properties: $properties, additionalProperties: count($properties) == 0 ? true : null);
	}

	if ($node instanceof NullableTypeNode) {
		$type = resolveOpenApiType($node->type);
		$type->nullable = true;
		return $type;
	}

	if ($node instanceof UnionTypeNode || $node instanceof IntersectionTypeNode) {
		$nullable = false;
		$types = [];
		foreach ($node->types as $type) {
			if ($type instanceof IdentifierTypeNode && $type->name == "null") {
				$nullable = true;
			} else {
				$types[] = $type;
			}
		}

		if (count($types) == 1) {
			$type = resolveOpenApiType($types[0]);
			$type->nullable = true;
			return $type;
		} else {
			return new OpenApiType(
				nullable: $nullable,
				anyOf: $node instanceof UnionTypeNode ? $types : null,
				allOf: $node instanceof IntersectionTypeNode ? $types : null,
			);
		}
	}

	die("Unable to resolve OpenAPI type for " . get_class($node) . "\n");
}

class OpenApiType
{
	public ?string $type;

	public ?string $format;

	public ?bool $nullable;

	public mixed $defaultValue;

	public ?OpenApiType $items;

	public ?array $properties;

	public ?array $anyOf;

	public ?array $allOf;

	public ?bool $additionalProperties;

	public function __construct(?string $type = null, ?string $format = null, ?bool $nullable = null, mixed $defaultValue = null, ?OpenApiType $items = null, ?array $properties = null, ?array $anyOf = null, ?array $allOf = null, ?bool $additionalProperties = null)
	{
		$this->type = $type;
		$this->format = $format;
		$this->nullable = $nullable;
		$this->defaultValue = $defaultValue;
		$this->items = $items;
		$this->properties = $properties;
		$this->anyOf = $anyOf;
		$this->allOf = $allOf;
		$this->additionalProperties = $additionalProperties;
	}

	public function toSchema(bool $booleanQuirk): Schema
	{
		return new Schema(array_merge(
			$this->type != null ? ["type" => $booleanQuirk && $this->type == "boolean" ? "integer" : $this->type] : [],
			$this->format != null ? ["format" => $this->format] : [],
			$this->defaultValue != null ? ["default" => $booleanQuirk && $this->type == "boolean" ? $this->defaultValue == "true" ? 1 : 0 : $this->defaultValue] : [],
			$this->items != null ? ["items" => $this->items->toSchema($booleanQuirk)] : [],
			$this->properties != null ? ["properties" =>
				array_combine(array_keys($this->properties),
					array_map(function (OpenApiType $property) use ($booleanQuirk) {
						return $property->toSchema($booleanQuirk);
					}, array_values($this->properties)),
				)] : [],
			$this->anyOf != null ? ["anyOf" => array_map(function (TypeNode $node) use ($booleanQuirk) {
				return resolveOpenApiType($node)->toSchema($booleanQuirk);
			}, $this->anyOf)] : [],
			$this->allOf != null ? ["allOf" => array_map(function (TypeNode $node) use ($booleanQuirk) {
				return resolveOpenApiType($node)->toSchema($booleanQuirk);
			}, $this->allOf)] : [],
			$this->additionalProperties != null ? ["additionalProperties" => $this->additionalProperties] : [],
		));
	}
}

function findMethod(array $ast, string $controllerName, string $methodName): ?ClassMethod
{
	foreach ($ast as $node1) {
		if ($node1 instanceof Namespace_) {
			foreach ($node1->stmts as $node2) {
				if ($node2 instanceof Class_ && $node2->name == $controllerName . "Controller") {
					foreach ($node2->stmts as $node3) {
						if ($node3 instanceof ClassMethod) {
							if ($node3->name == $methodName) {
								$doc = $node3->getDocComment()?->getText();
								if ($node2->extends != "Controller" || ($doc != null && str_contains($doc, "@NoCSRFRequired"))) {
									return $node3;
								} else {
									return null;
								}
							}
						}
					}
				}
			}
		}
	}

	return null;
}

function parseRoutes(string $path): array
{
	$content = file_get_contents($path);
	if (str_contains($content, "return ")) {
		return include($path);
	} elseif (str_contains($content, "registerRoutes")) {
		preg_match("/registerRoutes\(\\\$this, (\[[^;]*)\);/", $content, $matches);

		$tmpPath = tempnam(sys_get_temp_dir(), "routes-");
		file_put_contents($tmpPath, "<?php\nreturn " . $matches[1] . ";");
		$routes = include($tmpPath);
		unlink($tmpPath);

		return $routes;
	} else {
		die("Unknown routes.php format\n");
	}
}

function cleanDocComment(string $comment): string
{
	return trim(preg_replace("/\s+/", " ", $comment));
}

function splitOnUppercaseFollowedByNonUppercase(string $str): array
{
	return preg_split('/(?=[A-Z][^A-Z])/', $str, -1, PREG_SPLIT_NO_EMPTY);
}

function generateOperationID(string $methodName, string $controllerName): string
{
	$verbParts = array_map(function (string $verbPart) {
		return strtolower($verbPart);
	}, splitOnUppercaseFollowedByNonUppercase($methodName));
	$verb = mapVerb(implode("-", $verbParts));

	$objectParts = array_filter(array_map(function (string $objectPart) {
		return strtolower($objectPart);
	}, splitOnUppercaseFollowedByNonUppercase($controllerName)), function (string $objectPart) {
		return !in_array($objectPart, ["api", "endpoint"]);
	});
	$object = implode("-", $objectParts);

	if (array_intersect($objectParts, $verbParts) == $objectParts || $object == "") {
		return $verb;
	}
	if (array_intersect($verbParts, $objectParts) == $verbParts) {
		return $object;
	}

	if (count($verbParts) == 1) {
		// Make it plural when listing
		if ($verb == "list" && !str_ends_with($object, "s")) {
			$object .= "s";
		}

		return "$verb-$object";
	}

	return "$object-$verb";
}

function mapVerb(string $verb): string
{
	return match ($verb) {
		"index" => "list",
		default => $verb,
	};
}