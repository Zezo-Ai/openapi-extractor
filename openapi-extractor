#!/usr/bin/env php
<?php

require_once __DIR__ . "/vendor/autoload.php";

use Ahc\Cli\Input\Command;
use cebe\openapi\spec\Header;
use cebe\openapi\spec\Info;
use cebe\openapi\spec\MediaType;
use cebe\openapi\spec\OpenApi;
use cebe\openapi\spec\Operation;
use cebe\openapi\spec\Parameter;
use cebe\openapi\spec\PathItem;
use cebe\openapi\spec\Response;
use cebe\openapi\spec\Schema;
use cebe\openapi\spec\SecurityRequirement;
use cebe\openapi\spec\Tag;
use cebe\openapi\Writer;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Expr\ClassConstFetch;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Expr\New_;
use PhpParser\Node\Expr\UnaryMinus;
use PhpParser\Node\Identifier;
use PhpParser\Node\IntersectionType;
use PhpParser\Node\Name;
use PhpParser\Node\NullableType;
use PhpParser\Node\Param;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Return_;
use PhpParser\Node\Stmt\Throw_;
use PhpParser\Node\UnionType;
use PhpParser\NodeAbstract;
use PhpParser\NodeFinder;
use PhpParser\ParserFactory;
use PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprStringNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\ParamTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTextNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\ReturnTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\ThrowsTagValueNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\TypeAliasTagValueNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayShapeNode;
use PHPStan\PhpDocParser\Ast\Type\ArrayTypeNode;
use PHPStan\PhpDocParser\Ast\Type\ConstTypeNode;
use PHPStan\PhpDocParser\Ast\Type\GenericTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode;
use PHPStan\PhpDocParser\Ast\Type\IntersectionTypeNode;
use PHPStan\PhpDocParser\Ast\Type\NullableTypeNode;
use PHPStan\PhpDocParser\Ast\Type\TypeNode;
use PHPStan\PhpDocParser\Ast\Type\UnionTypeNode;
use PHPStan\PhpDocParser\Lexer\Lexer;
use PHPStan\PhpDocParser\Parser\ConstExprParser;
use PHPStan\PhpDocParser\Parser\PhpDocParser;
use PHPStan\PhpDocParser\Parser\TokenIterator;
use PHPStan\PhpDocParser\Parser\TypeParser;

$responseTypePrefixes = ["JSON", "Data", "FileDisplay", "DataDisplay", "Redirect", "Template", "DataDownload"];
$responseTypes = [];
foreach ($responseTypePrefixes as $responseTypePrefix) {
	$responseTypes[] = $responseTypePrefix . "Response";
}

$command = new Command("openapi-extractor", "Extract OpenAPI specs from the Nextcloud source code");
$command
	->arguments("dir out")
	->option('--first-status-code', 'Only output the first status code')
	->option('--first-content-type', 'Only output the first content type')
	->option('--allow-missing-docs', 'Allow missing documentation fields')
	->option('--no-tags', 'Use no tags')
	->parse($_SERVER["argv"]);

$dir = $command->dir;
$out = $command->out;
$firstStatusCode = $command->firstStatusCode ?? false;
$firstContentType = $command->firstContentType ?? false;
$allowMissingDocs = $command->allowMissingDocs ?? false;
$useTags = $command->tags ?? true;

if ($dir == "") {
	$dir = ".";
}
if ($out == "") {
	$out = "openapi.json";
}

$astParser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);
$nodeFinder = new NodeFinder;

$lexer = new Lexer();
$constExprParser = new ConstExprParser();
$typeParser = new TypeParser($constExprParser);
$phpDocParser = new PhpDocParser($typeParser, $constExprParser);

$infoXMLPath = join("/", [$dir, "appinfo", "info.xml"]);

if (file_exists($infoXMLPath)) {
	$xml = simplexml_load_file($infoXMLPath);

	$appIsCore = false;
	$appID = (string)$xml->id;
	$appName = (string)$xml->name;
	$appSummary = (string)$xml->summary;
	$appVersion = (string)$xml->version;
	$appLicence = (string)$xml->licence;
} else {
	$versionPHPPath = join("/", [$dir, "..", "version.php"]);

	if (!file_exists($versionPHPPath)) {
		throw new Exception("Neither " . $infoXMLPath . " nor " . $versionPHPPath . " exists");
	}

	// Includes https://github.com/nextcloud/server/blob/master/version.php when running inside https://github.com/nextcloud/server/tree/master/core
	include(join("/", [$dir, "..", "version.php"]));
	if (!isset($OC_VersionString)) {
		throw new Exception("Unable to figure out core version");
	}

	$appIsCore = true;
	$appID = "core";
	$appName = "Core";
	$appSummary = "Core functionality of Nextcloud";
	$appVersion = $OC_VersionString;
	$appLicence = "agpl";
}

$readableAppID = implode("", array_map(fn(string $s) => ucfirst($s), explode("_", $appID)));

$openapi = new OpenApi([
	"openapi" => "3.0.3",
	"info" => new Info([
		"title" => $appName,
		"version" => $appVersion,
		"description" => $appSummary,
		"license" => [
			"name" => $appLicence,
		],
	]),
	"security" => [
		new SecurityRequirement([
			"basic_auth" => [],
		]),
	],
	"components" => [
		"securitySchemes" => [
			"basic_auth" => [
				"type" => "http",
				"scheme" => "basic",
			]
		],
		"schemas" => [],
	],
	"paths" => [],
]);

print_r("Extracting OpenAPI spec for " . $appName . " " . $appVersion . "\n");

$schemas = [];
$tags = [];

$definitions = [];
$definitionsPath = join("/", [$dir, "lib", "ResponseDefinitions.php"]);
if (file_exists($definitionsPath)) {
	foreach ($nodeFinder->findInstanceOf(loadAST($definitionsPath), Class_::class) as $node) {
		$doc = $node->getDocComment()?->getText();
		if ($doc != null) {
			$docNodes = $phpDocParser->parse(new TokenIterator($lexer->tokenize($doc)))->children;
			foreach ($docNodes as $docNode) {
				if ($docNode instanceof PhpDocTagNode && $docNode->value instanceof TypeAliasTagValueNode) {
					if (!str_starts_with($docNode->value->alias, $readableAppID)) {
						throw new Exception("Type alias '" . $docNode->value->alias . "' has to start with '" . $readableAppID . "'");
					}
					$definitions[$docNode->value->alias] = resolveOpenApiType("Response definitions", $docNode->value->type)->toSchema();
				}
			}
		}
	}
} else {
	print_r("No response definitions were loaded\n");
}

$parsedRoutes = parseRoutes(join("/", $appIsCore ? [$dir, "routes.php"] : [$dir, "appinfo", "routes.php"]));
$seenRouteNames = [];

if (array_key_exists("routes", $parsedRoutes) && array_key_exists("ocs", $parsedRoutes)) {
	$parsedRoutes = ["ocs" => $parsedRoutes["ocs"]];
}

foreach ($parsedRoutes as $key => $value) {
	if ($key != "routes" && $key != "ocs") {
		continue;
	}
	foreach ($value as $route) {
		$routeName = $route["name"];

		$postfix = array_key_exists("postfix", $route) ? $route["postfix"] : null;
		$verb = array_key_exists("verb", $route) ? $route["verb"] : "GET";
		$requirements = array_key_exists("requirements", $route) ? $route["requirements"] : [];
		$root = array_key_exists("root", $route) ? $route["root"] : ($appIsCore ? "" : "/apps") . "/" . $appID;
		$url = $route["url"];
		if (!str_starts_with($url, "/")) {
			$url = "/" . $url;
		}
		if (str_ends_with($url, "/")) {
			$url = substr($url, 0, -1);
		}
		if ($key == "routes") {
			$url = "/index.php" . $root . $url;
		}
		if ($key == "ocs") {
			$url = "/ocs/v2.php" . $root . $url;
		}

		$methodName = lcfirst(str_replace("_", "", ucwords(explode("#", $routeName)[1], "_")));
		if ($methodName == "preflightedCors") {
			continue;
		}

		$controllerName = ucfirst(str_replace("_", "", ucwords(explode("#", $routeName)[0], "_")));
		$controllerClass = null;
		/** @var Class_ $class */
		foreach ($nodeFinder->findInstanceOf(loadAST(join("/", $appIsCore ? [$dir, "Controller", $controllerName . "Controller.php"] : [$dir, "lib", "Controller", $controllerName . "Controller.php"])), Class_::class) as $class) {
			if ($class->name == $controllerName . "Controller") {
				$controllerClass = $class;
				break;
			}
		}
		if ($controllerClass == null) {
			throw new Exception($routeName . ": Controller '" . $controllerName . "' not found");
		}

		$tagName = implode("_", array_map(fn(string $s) => strtolower($s), splitOnUppercaseFollowedByNonUppercase($controllerName)));
		$doc = $controllerClass->getDocComment()?->getText();
		if ($doc != null && count(array_filter($tags, fn(Tag $tag) => $tag->name == $tagName)) == 0) {
			$classDescription = [];

			$docNodes = $phpDocParser->parse(new TokenIterator($lexer->tokenize($doc)))->children;
			foreach ($docNodes as $docNode) {
				if ($docNode instanceof PhpDocTextNode) {
					$block = cleanDocComment($docNode->text);
					if ($block == "") {
						continue;
					}
					$classDescription[] = $block;
				}
			}

			if (count($classDescription) > 0) {
				$tags[] = new Tag([
					"name" => $tagName,
					"description" => join("\n", $classDescription),
				]);
			}
		}

		$methodFunction = null;
		$isOCS = false;
		$isAdmin = true;
		/** @var ClassMethod $classMethod */
		foreach ($nodeFinder->findInstanceOf($controllerClass->stmts, ClassMethod::class) as $classMethod) {
			if ($classMethod->name == $methodName) {
				$doc = $classMethod->getDocComment()?->getText();
				if ($controllerClass->extends != "Controller" || ($doc != null && str_contains($doc, "@NoCSRFRequired"))) {
					$methodFunction = $classMethod;
					$isOCS = $controllerClass->extends != "Controller" && $controllerClass->extends != "ApiController";
					$isAdmin = !str_contains($doc, "@NoAdminRequired") && !str_contains($doc, "@PublicPage");
					break;
				}
			}
		}
		if ($methodFunction == null) {
			print_r($routeName . ": Route ignored\n");
			continue;
		}

		if ($isOCS && !array_key_exists("OCSMeta", $schemas)) {
			$schemas["OCSMeta"] = [
				"type" => "object",
				"required" => [
					"status",
					"statuscode",
				],
				"properties" => [
					"status" => ["type" => "string"],
					"statuscode" => ["type" => "integer"],
					"message" => ["type" => "string"],
					"totalitems" => ["type" => "string"],
					"itemsperpage" => ["type" => "string"],
				],
			];
		}

		$classMethodInfo = extractMethodInfo($routeName, $methodFunction, $isOCS, $isAdmin);
		if (count($classMethodInfo->returns) > 0) {
			throw new Exception($routeName . ": Returns an invalid response");
		}
		if (count($classMethodInfo->responses) == 0) {
			throw new Exception($routeName . ": Returns no responses");
		}

		$codeStatusCodes = [];
		/* @var $returnStatement Return_ */
		foreach ($nodeFinder->findInstanceOf($methodFunction->stmts, Return_::class) as $returnStatement) {
			if ($returnStatement->expr instanceof New_ && $returnStatement->expr->class instanceof Name && in_array($returnStatement->expr->class->getLast(), $responseTypes)) {
				if (count($returnStatement->expr->args) >= 2) {
					if ($returnStatement->expr->args[1]->value instanceof ClassConstFetch) {
						$codeStatusCodes[] = statusEnumToCode($routeName, $returnStatement->expr->args[1]->value->name->name);
					} else {
						print_r($routeName . ": Return statement could not be understood\n");
					}
				} else {
					$codeStatusCodes[] = 200;
				}
			}
		}

		/* @var $throwStatement Throw_ */
		foreach ($nodeFinder->findInstanceOf($methodFunction->stmts, Throw_::class) as $throwStatement) {
			if ($throwStatement->expr instanceof New_ && $throwStatement->expr->class instanceof Name) {
				$type = $throwStatement->expr->class->getLast();
				$statusCode = exceptionToStatusCode($routeName, $type);
				if ($statusCode != null) {
					$codeStatusCodes[] = $statusCode;
				}
			}
		}

		$docStatusCodes = array_map(fn(ClassMethodResponse $response) => $response->statusCode, array_filter($classMethodInfo->responses, fn(?ClassMethodResponse $response) => $response != null));
		$missingDocStatusCodes = array_unique(array_filter(array_diff($codeStatusCodes, $docStatusCodes), fn(int $code) => $code < 500));
		$missingCodeStatusCodes = array_unique(array_diff($docStatusCodes, $codeStatusCodes));

		if (count($missingDocStatusCodes) > 0) {
			print_r($routeName . ": Returns undocumented status codes: " . implode(", ", $missingDocStatusCodes) . "\n");
		}
		if (count($missingCodeStatusCodes) > 0) {
			print_r($routeName . ": Documents status codes which are never returned: " . implode(", ", $missingCodeStatusCodes) . "\n");
		}

		$routes[] = new Route(
			$routeName,
			$tagName,
			$controllerName,
			$methodName,
			$postfix,
			$verb,
			$url,
			$requirements,
			$classMethodInfo,
		);
	}
}

$tagNames = [];
if ($useTags) {
	foreach ($routes as $route) {
		if (!in_array($route->tag, $tagNames)) {
			$tagNames[] = $route->tag;
		}
	}
}

foreach ($routes as $route) {
	$pathParameters = [];
	$urlParameters = [];

	preg_match_all("/{[^}]*}/", $route->url, $urlParameters);
	$urlParameters = array_map(fn(string $name) => substr($name, 1, -1), $urlParameters[0]);

	if (!$openapi->paths->hasPath($route->url)) {
		foreach ($urlParameters as $urlParameter) {
			$matchingParameters = array_filter($route->classMethodInfo->parameters, function (ClassMethodParameter $param) use ($urlParameter) {
				return $param->name == $urlParameter;
			});
			if (count($matchingParameters) == 1) {
				$parameter = $matchingParameters[array_keys($matchingParameters)[0]];
				if ($parameter?->methodParameter == null && ($route->requirements == null || !array_key_exists($urlParameter, $route->requirements))) {
					throw new Exception($route->name . ": Unable to find parameter for '" . $urlParameter . "'");
				}

				$pathParameters[] = new Parameter(array_merge(
					[
						"name" => $urlParameter,
						"in" => "path",
						"required" => true,
						"schema" => $parameter->type->toSchema(true),
					],
					$parameter?->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
				));
			} else {
				$requirement = array_key_exists($urlParameter, $route->requirements) ? $route->requirements[$urlParameter] : null;
				if ($requirement != null) {
					if (!str_starts_with($requirement, "^")) {
						$requirement = "^" . $requirement;
					}
					if (!str_ends_with($requirement, "$")) {
						$requirement = $requirement . "$";
					}
				}
				$pathParameters[] = new Parameter(array_merge(
					[
						"name" => $urlParameter,
						"in" => "path",
						"required" => true,
						"schema" => array_merge(
							$requirement != null ? [
								"type" => "string",
								"pattern" => $requirement,
							] : [],
						),
					],
				));
			}
		}

		$openapi->paths->addPath(
			$route->url,
			new PathItem([
				"parameters" => $pathParameters,
			]),
		);
	} else {
		$pathParameters = $openapi->paths->getPath($route->url)->parameters;
	}

	$queryParameters = [];
	foreach ($route->classMethodInfo->parameters as $parameter) {
		$alreadyInPath = false;
		foreach ($pathParameters as $pathParameter) {
			if ($pathParameter->name == $parameter->name) {
				$alreadyInPath = true;
				break;
			}
		}
		if (!$alreadyInPath) {
			$queryParameters[] = $parameter;
		}
	}

	$mergedResponses = [];
	foreach (array_unique(array_map(fn(ClassMethodResponse $response) => $response->statusCode, array_filter($route->classMethodInfo->responses, fn(?ClassMethodResponse $response) => $response != null))) as $statusCode) {
		if ($firstStatusCode && count($mergedResponses) > 0) {
			break;
		}

		$statusCodeResponses = array_filter($route->classMethodInfo->responses, fn(?ClassMethodResponse $response) => $response != null && $response->statusCode == $statusCode);
		$headers = array_merge(...array_map(fn(ClassMethodResponse $response) => $response->headers ?? [], $statusCodeResponses));

		$mergedContentTypeResponses = [];
		foreach (array_unique(array_map(fn(ClassMethodResponse $response) => $response->contentType, array_filter($statusCodeResponses, fn(ClassMethodResponse $response) => $response->contentType != null))) as $contentType) {
			if ($firstContentType && count($mergedContentTypeResponses) > 0) {
				break;
			}

			$contentTypeResponses = array_values(array_filter($statusCodeResponses, fn(ClassMethodResponse $response) => $response->contentType == $contentType));

			$hasEmpty = count(array_filter($contentTypeResponses, fn(ClassMethodResponse $response) => $response->type == null)) > 0;
			$uniqueResponses = array_values(array_intersect_key($contentTypeResponses, array_unique(array_map(fn(ClassMethodResponse $response) => $response->type->toSchema(), array_filter($contentTypeResponses, fn(ClassMethodResponse $response) => $response->type != null)), SORT_REGULAR)));
			if (count($uniqueResponses) == 1) {
				if ($hasEmpty) {
					$mergedContentTypeResponses[$contentType] = new MediaType([]);
				} else {
					$schema = $contentTypeResponses[0]->type->toSchema();
					$mergedContentTypeResponses[$contentType] = new MediaType(["schema" => $uniqueResponses[0]->isOCS ? wrapOCSResponse($schema) : $schema]);
				}
			} else {
				$mergedContentTypeResponses[$contentType] = new MediaType([
					"schema" => [
						$hasEmpty ? "anyOf" : "oneOf" => array_map(fn(ClassMethodResponse $response) => $response->type->toSchema(), $uniqueResponses),
					],
				]);
			}
		}

		$mergedResponses[$statusCode] = new Response(
			array_merge(
				[
					"description" => array_key_exists($statusCode, $route->classMethodInfo->responseDescription) ? $route->classMethodInfo->responseDescription[$statusCode] : "",
				],
				count($mergedContentTypeResponses) > 0 ? [
					"content" => $mergedContentTypeResponses,
				] : [],
				count($headers) > 0 ? [
					"headers" => array_combine(
						array_keys($headers),
						array_map(
							fn(OpenApiType $type) => new Header([
								"schema" => $type->toSchema(),
							]),
							array_values($headers),
						),
					),
				] : [],
			),
		);
	}

	$operationId = [$route->tag];
	$operationId = array_merge($operationId, array_map(fn(string $s) => mapVerb(strtolower($s)), splitOnUppercaseFollowedByNonUppercase($route->methodName)));
	if ($route->postfix != null) {
		$operationId[] = $route->postfix;
	}

	$operation = new Operation(array_merge([
		"operationId" => implode("-", $operationId),
		"responses" => $mergedResponses,
	],
		$useTags ? ["tags" => [$route->tag]] : [],
		$route->classMethodInfo->summary != null ? ["summary" => $route->classMethodInfo->summary] : [],
		count($route->classMethodInfo->description) > 0 ? ["description" => implode("\n", $route->classMethodInfo->description)] : [],
		count($queryParameters) > 0 ? [
			"parameters" => array_map(fn(ClassMethodParameter $parameter) => new Parameter(array_merge(
				[
					"name" => $parameter->name,
					"in" => "query",
					"schema" => $parameter->type->toSchema(true),
				],
				!$parameter->type->nullable && $parameter->type->defaultValue === null ? ["required" => true] : [],
				$parameter->docParameter != null && $parameter->docParameter->description != "" ? ["description" => cleanDocComment($parameter->docParameter->description)] : [],
			)), $queryParameters),
		] : []),
	);
	switch ($route->verb) {
		case "DELETE":
			$openapi->paths->getPath($route->url)->delete = $operation;
			break;
		case "GET":
			$openapi->paths->getPath($route->url)->get = $operation;
			break;
		case "POST":
			$openapi->paths->getPath($route->url)->post = $operation;
			break;
		case "PUT":
			$openapi->paths->getPath($route->url)->put = $operation;
			break;
		case "PATCH":
			$openapi->paths->getPath($route->url)->patch = $operation;
			break;
		case "OPTIONS":
			$openapi->paths->getPath($route->url)->options = $operation;
			break;
	}
}

function wrapOCSResponse(Schema $schema): array {
	return [
		"type" => "object",
		"required" => [
			"ocs",
		],
		"properties" => [
			"ocs" => [
				"type" => "object",
				"required" => [
					"meta",
					"data",
				],
				"properties" => [
					"meta" => [
						"\$ref" => "#/components/schemas/OCSMeta",
					],
					"data" => $schema,
				],
			],
		],
	];
}

class Route {
	public function __construct(
		public string $name,
		public string $tag,
		public string $controllerName,
		public string $methodName,
		public ?string $postfix,
		public string $verb,
		public string $url,
		public array $requirements,
		public ClassMethodInfo $classMethodInfo,
	) {
	}
}

ksort($schemas);
$openapi->components->schemas = $schemas;

if ($useTags) {
	$openapi->tags = $tags;
}

file_put_contents($out, Writer::writeToJson($openapi, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));
if (!$openapi->validate()) {
	throw new Exception("Invalid OpenAPI spec generated. Please review the output!");
}

function extractMethodInfo(string $context, ClassMethod $method, bool $isOCS, bool $isAdmin): ClassMethodInfo {
	global $phpDocParser, $lexer, $allowMissingDocs;

	$parameters = [];
	$responses = [];
	$responseDescriptions = [];
	$returns = [];

	$methodDescription = [];
	$methodSummary = null;
	$methodParameters = $method->getParams();
	$docParameters = [];

	$doc = $method->getDocComment()?->getText();
	if ($doc != null) {
		$docNodes = $phpDocParser->parse(new TokenIterator($lexer->tokenize($doc)))->children;

		foreach ($docNodes as $docNode) {
			if ($docNode instanceof PhpDocTextNode) {
				$block = cleanDocComment($docNode->text);
				if ($block == "") {
					continue;
				}
				$pattern = "/([0-9]{3}): /";
				if (preg_match($pattern, $block)) {
					$parts = preg_split($pattern, $block, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
					for ($i = 0; $i < count($parts); $i += 2) {
						$statusCode = intval($parts[$i]);
						$responseDescriptions[$statusCode] = trim($parts[$i + 1]);
					}
				} else {
					$methodDescription[] = $block;
				}
			}
		}

		foreach ($docNodes as $docNode) {
			if ($docNode instanceof PhpDocTagNode) {
				if ($docNode->value instanceof ParamTagValueNode) {
					$docParameters[] = $docNode->value;
				}

				if ($docNode->value instanceof ReturnTagValueNode) {
					$type = $docNode->value->type;

					resolveReturnType($context, $responses, $returns, $responseDescriptions, $type);
				}

				if ($docNode->value instanceof ThrowsTagValueNode) {
					$type = $docNode->value->type;
					$statusCode = exceptionToStatusCode($context, $type);
					if ($statusCode != null) {
						if (!$allowMissingDocs && $docNode->value->description == "" && $statusCode < 500) {
							throw new Exception($context . ": Missing description for exception '" . $type . "'");
						}
						$responseDescriptions[$statusCode] = $docNode->value->description;
						$responses[] = new ClassMethodResponse($statusCode, "text/plain", new OpenApiType(type: "string"), $isOCS, null);
					}
				}
			}
		}
	}

	if (!$allowMissingDocs && count($responses) > 1) {
		foreach (array_unique(array_map(fn(ClassMethodResponse $response) => $response->statusCode, array_filter($responses, fn(?ClassMethodResponse $response) => $response != null))) as $statusCode) {
			if ($statusCode < 500 && (!array_key_exists($statusCode, $responseDescriptions) || $responseDescriptions[$statusCode] == "")) {
				throw new Exception($context . ": Missing description for status code " . $statusCode);
			}
		}
	}

	foreach ($methodParameters as $methodParameter) {
		$param = null;
		$methodParameterName = $methodParameter->var->name;

		foreach ($docParameters as $docParameter) {
			$docParameterName = substr($docParameter->parameterName, 1);

			if ($docParameterName == $methodParameterName) {
				$param = new ClassMethodParameter($context, $methodParameterName, $methodParameter, $docParameter);
				break;
			}
		}

		if ($param == null) {
			if ($allowMissingDocs) {
				$param = new ClassMethodParameter($context, $methodParameterName, $methodParameter, null);
			} else {
				throw new Exception($context . ": Missing doc parameter for '" . $methodParameterName . "'");
			}
		}

		if (!$allowMissingDocs && $param->type->description == "") {
			throw new Exception($context . ": Missing description for parameter '" . $methodParameterName . "'");
		}

		$parameters[] = $param;
	}

	if (!$allowMissingDocs && count($methodDescription) == 0) {
		throw new Exception($context . ": Missing method description");
	}

	if ($isAdmin) {
		$methodDescription[] = "This endpoint requires admin access";
	}

	if (count($methodDescription) == 1) {
		$methodSummary = $methodDescription[0];
		$methodDescription = [];
	} else if (count($methodDescription) > 1) {
		$methodSummary = $methodDescription[0];
		$methodDescription = array_slice($methodDescription, 1);
	}

	if (preg_match("/[.,!?:-]$/", $methodSummary)) {
		throw new Exception($context . ": Summary ends with a punctuation mark");
	}

	return new ClassMethodInfo($parameters, array_values($responses), $returns, $responseDescriptions, $methodDescription, $methodSummary);
}

function resolveReturnType(string $context, &$responses, &$returns, $responseDescriptions, TypeNode $type): void {
	global $responseTypes, $isOCS;
	if ($type instanceof IdentifierTypeNode && $type->name == "RedirectResponse") {
		$responses[] = new ClassMethodResponse(
			303,
			null,
			null,
			$isOCS,
			["Location" => new OpenApiType(type: "string")],
		);
	} else if ($type instanceof IdentifierTypeNode && $type->name == "void") {
		$responses[] = null;
	} else if ($type instanceof GenericTypeNode && $type->type->name == "DataDownloadResponse") {
		$responses[] = new ClassMethodResponse(
			200,
			$type->genericTypes[0]->constExpr->value,
			new OpenApiType(type: "string"),
			$isOCS,
			null,
		);
	} else if ($type instanceof GenericTypeNode && in_array($type->type->name, $responseTypes)) {
		if ($type->type->name == "FileDisplayResponse" || $type->type->name == "DataDisplayResponse" || $type->type->name == "TemplateResponse") {
			$statusCodeNode = $type->genericTypes[0];
			$realType = new OpenApiType(type: "string", format: $type->type->name == "FileDisplayResponse" ? "binary" : null);
			if ($type->type->name == "TemplateResponse") {
				$contentType = "text/html";
			} else {
				// TODO: This is really annoying, because we need to match any content type since it's not possible to know which one will be returned
				$contentType = "*/*";
			}
		} else {
			if (count($type->genericTypes) != 2) {
				throw new Exception($context . ": '" . $type->type->name . "' needs two parameters");
			}
			$statusCodeNode = $type->genericTypes[1];
			$realType = resolveOpenApiType($context, $type->genericTypes[0]);
			$contentType = "application/json";
		}
		$statusCodes = [];
		$statusCodeNodes = [];
		if ($statusCodeNode instanceof UnionTypeNode) {
			$statusCodeNodes = $statusCodeNode->types;
		} else {
			$statusCodeNodes[] = $statusCodeNode;
		}
		foreach ($statusCodeNodes as $node) {
			$statusCodes[] = statusEnumToCode($context, $node->constExpr->name);
		}
		foreach ($statusCodes as $statusCode) {
			$responses[] = new ClassMethodResponse(
				$statusCode,
				$contentType,
				$realType,
				$isOCS,
				null,
			);
		}
	} else if ($type instanceof UnionTypeNode) {
		foreach ($type->types as $subType) {
			resolveReturnType($context, $responses, $returns, $responseDescriptions, $subType);
		}
	} else {
		throw new Exception($context . ": Invalid return type '" . $type . "'");
	}
}

function statusEnumToCode(string $context, string $name): int {
	return match ($name) {
		"STATUS_OK" => 200,
		"STATUS_CREATED" => 201,
		"STATUS_ACCEPTED" => 202,
		"STATUS_NO_CONTENT" => 204,
		"STATUS_NOT_MODIFIED" => 304,
		"STATUS_BAD_REQUEST" => 400,
		"STATUS_UNAUTHORIZED" => 401,
		"STATUS_FORBIDDEN" => 403,
		"STATUS_NOT_FOUND" => 404,
		"STATUS_METHOD_NOT_ALLOWED" => 405,
		"STATUS_NOT_ACCEPTABLE" => 406,
		"STATUS_CONFLICT" => 409,
		"STATUS_PRECONDITION_FAILED" => 412,
		"STATUS_REQUEST_ENTITY_TOO_LARGE" => 413,
		"STATUS_LOCKED" => 423,
		"STATUS_INTERNAL_SERVER_ERROR" => 500,
		"STATUS_NOT_IMPLEMENTED" => 501,
		"STATUS_INSUFFICIENT_STORAGE" => 507,
		default => throw new Exception($context . ": Unknown status code '" . $name . "'"),
	};
}

function exceptionToStatusCode(string $context, string $name): ?int {
	if (!str_starts_with($name, "OCS")) {
		return 500;
	}
	return match ($name) {
		"OCSException" => null,
		"OCSBadRequestException" => 400,
		"OCSForbiddenException" => 403,
		"OCSNotFoundException" => 404,
		default => throw new Exception($context . ": Unknown exception '" . $name . "'"),
	};
}

class ClassMethodInfo {
	/**
	 * @param ClassMethodParameter[] $parameters
	 * @param ClassMethodResponse[] $responses
	 * @param OpenApiType[] $returns
	 * @param array<int, string> $responseDescription
	 * @param string[] $description
	 */
	public function __construct(public array $parameters, public array $responses, public array $returns, public array $responseDescription, public array $description, public ?string $summary) {
	}
}

class ClassMethodResponse {
	/**
	 * @param array<string, OpenApiType>|null $headers
	 */
	public function __construct(public int $statusCode, public ?string $contentType, public ?OpenApiType $type, public bool $isOCS, public ?array $headers) {
	}

}

class ClassMethodParameter {
	public OpenApiType $type;

	public function __construct(string $context, public string $name, public Param $methodParameter, public ?ParamTagValueNode $docParameter) {
		if ($docParameter != null) {
			$this->type = resolveOpenApiType($context, $docParameter);
		} else {
			$this->type = resolveOpenApiType($context, $methodParameter->type);
		}
		if ($methodParameter->default != null) {
			$this->type->defaultValue = exprToString($context, $methodParameter->default);
		}
	}
}

function exprToString(string $context, null|Expr $expr): mixed {
	if ($expr == null) {
		return null;
	}
	if ($expr instanceof ConstFetch) {
		$value = $expr->name->getLast();
		switch ($value) {
			case "null":
				return null;
			case "true":
				return true;
			case "false":
				return false;
			default:
				throw new Exception($context . ": Unable to evaluate constant value '" . $value . "'");
		}
	}
	if ($expr instanceof String_) {
		return $expr->value;
	}
	if ($expr instanceof LNumber) {
		return intval($expr->value);
	}
	if ($expr instanceof UnaryMinus) {
		return exprToString($context, $expr->expr);
	}
	if ($expr instanceof Array_) {
		return array_map(fn(ArrayItem $item) => exprToString($context, $item), $expr->items);
	}

	throw new Exception($context . ": Unable to evaluate expression '" . get_class($expr) . "'");
}

function resolveIdentifier(string $context, string $name): OpenApiType {
	global $openapi, $definitions, $schemas, $dir, $readableAppID;
	return match ($name) {
		"string" => new OpenApiType(type: "string", nullable: false),
		"non-empty-string" => new OpenApiType(type: "string", nullable: false, minLength: 1),
		"int", "integer" => new OpenApiType(type: "integer", nullable: false),
		"bool", "boolean" => new OpenApiType(type: "boolean", nullable: false),
		"double" => new OpenApiType(type: "number", format: "double", nullable: false),
		"float" => new OpenApiType(type: "number", format: "float", nullable: false),
		"array" => new OpenApiType(type: "object", nullable: false),
		"object" => new OpenApiType(type: "object", nullable: false, additionalProperties: true),
		"null" => new OpenApiType(nullable: true),
		default => (function () use ($context, $dir, $definitions, &$schemas, $openapi, $name, $readableAppID) {
			if (array_key_exists($name, $definitions)) {
				$cleanedName = str_replace($readableAppID, "", $name);
				if (!array_key_exists($cleanedName, $schemas)) {
					$schemas[$cleanedName] = $definitions[$name];
				}
				return new OpenApiType(
					ref: "#/components/schemas/" . $cleanedName,
				);
			}
			throw new Exception($context . ": Unable to resolve OpenAPI type for identifier '" . $name . "'");
		})(),
	};
}

function resolveOpenApiType(string $context, ParamTagValueNode|NodeAbstract|TypeNode $node): OpenApiType {
	if ($node instanceof ParamTagValueNode) {
		$type = resolveOpenApiType($context, $node->type);
		$type->description = $node->description;
		return $type;
	}
	if ($node instanceof PhpParser\Node\Name) {
		return resolveIdentifier($context, $node->getLast());
	}
	if ($node instanceof IdentifierTypeNode || $node instanceof Identifier) {
		return resolveIdentifier($context, $node->name);
	}

	if ($node instanceof ArrayTypeNode) {
		return new OpenApiType(type: "array", nullable: false, items: resolveOpenApiType($context, $node->type));
	}

	if ($node instanceof ArrayShapeNode) {
		if (count($node->items) == 0) {
			throw new Exception($context . ": Use 'object' instead of 'array{}'");
		}
		$properties = [];
		$required = [];
		foreach ($node->items as $item) {
			$type = resolveOpenApiType($context, $item->valueType);
			$name = $item->keyName instanceof ConstExprStringNode ? $item->keyName->value : $item->keyName->name;
			$properties[$name] = $type;
			if (!$type->nullable) {
				$required[] = $name;
			}
		}
		return new OpenApiType(type: "object", nullable: false, properties: $properties, required: count($required) > 0 ? $required : null);
	}

	if ($node instanceof GenericTypeNode && $node->type->name == "array" && count($node->genericTypes) == 2 && $node->genericTypes[0] instanceof IdentifierTypeNode && $node->genericTypes[0]->name == "string") {
		return new OpenApiType(type: "object", additionalProperties: resolveOpenApiType($context, $node->genericTypes[1]));
	}

	if ($node instanceof NullableTypeNode || $node instanceof NullableType) {
		$type = resolveOpenApiType($context, $node->type);
		$type->nullable = true;
		return $type;
	}

	if (($node instanceof UnionTypeNode || $node instanceof UnionType) && count($node->types) == count(array_filter($node->types, fn($type) => $type instanceof ConstTypeNode && $type->constExpr instanceof ConstExprStringNode))) {
		$values = [];
		/** @var ConstTypeNode $type */
		foreach ($node->types as $type) {
			$values[] = $type->constExpr->value;
		}

		return new OpenApiType(type: "string", enum: $values);
	}

	if ($node instanceof UnionTypeNode || $node instanceof IntersectionTypeNode || $node instanceof UnionType || $node instanceof IntersectionType) {
		$nullable = false;
		$types = [];

		foreach ($node->types as $type) {
			if (($type instanceof IdentifierTypeNode || $type instanceof Identifier) && $type->name == "null") {
				$nullable = true;
			} else {
				$types[] = resolveOpenApiType($context, $type);
			}
		}

		if (count($types) == 1) {
			$type = $types[0];
			$type->nullable = true;
			return $type;
		}

		return new OpenApiType(
			nullable: $nullable,
			oneOf: $node instanceof UnionTypeNode || $node instanceof UnionType ? $types : null,
			allOf: $node instanceof IntersectionTypeNode || $node instanceof IntersectionType ? $types : null,
		);
	}

	throw new Exception($context . ": Unable to resolve OpenAPI type for type '" . get_class($node) . "'");
}

class OpenApiType {
	/**
	 * @param OpenApiType[]|null $oneOf
	 * @param OpenApiType[]|null $anyOf
	 * @param OpenApiType[]|null $allOf
	 */
	public function __construct(
		public ?string $ref = null,
		public ?string $type = null,
		public ?string $format = null,
		public ?bool $nullable = null,
		public mixed $defaultValue = null,
		public ?OpenApiType $items = null,
		public ?array $properties = null,
		public ?array $oneOf = null,
		public ?array $anyOf = null,
		public ?array $allOf = null,
		public bool|OpenApiType|null $additionalProperties = null,
		public ?array $required = null,
		public ?string $description = null,
		public ?int $minLength = null,
		public ?int $maxLength = null,
		public ?array $enum = null,
	) {
	}

	public function toSchema(bool $isParameter = false): Schema {
		return new Schema(array_merge(
			$this->ref != null ? ["\$ref" => $this->ref] : [],
			$this->type != null ? ["type" => $isParameter && $this->type == "boolean" ? "integer" : $this->type] : [],
			$this->format != null ? ["format" => $this->format] : [],
			$this->defaultValue !== null ? ["default" => $isParameter && $this->type == "boolean" ? $this->defaultValue == "true" ? 1 : 0 : $this->defaultValue] : [],
			$this->items != null ? ["items" => $this->items->toSchema($isParameter)] : [],
			$this->properties != null ? ["properties" =>
				array_combine(array_keys($this->properties),
					array_map(function (OpenApiType $property) use ($isParameter) {
						return $property->toSchema($isParameter);
					}, array_values($this->properties)),
				)] : [],
			$this->oneOf != null ? ["oneOf" => array_map(function (OpenApiType $type) use ($isParameter) {
				return $type->toSchema($isParameter);
			}, $this->oneOf)] : [],
			$this->anyOf != null ? ["anyOf" => array_map(function (OpenApiType $type) use ($isParameter) {
				return $type->toSchema($isParameter);
			}, $this->anyOf)] : [],
			$this->allOf != null ? ["allOf" => array_map(function (OpenApiType $type) use ($isParameter) {
				return $type->toSchema($isParameter);
			}, $this->allOf)] : [],
			$this->additionalProperties != null ? [
				"additionalProperties" => $this->additionalProperties instanceof OpenApiType ? $this->additionalProperties->toSchema() : $this->additionalProperties,
			] : [],
			$this->required != null && count($this->required) > 0 ? ["required" => $this->required] : [],
			$this->description != null && $this->description != "" && !$isParameter ? ["description" => $this->description] : [],
			$this->minLength != null && $this->minLength != 0 ? ["minLength" => $this->minLength] : [],
			$this->maxLength != null && $this->maxLength != 0 ? ["maxLength" => $this->maxLength] : [],
			$this->enum != null && count($this->enum) > 0 ? ["enum" => $this->enum] : [],
		));
	}
}

function loadAST(string $filename): array {
	global $astParser;
	return $astParser->parse(file_get_contents($filename));
}

function parseRoutes(string $path): array {
	$content = file_get_contents($path);
	if (str_contains($content, "return ")) {
		return include($path);
	} elseif (str_contains($content, "registerRoutes")) {
		preg_match("/registerRoutes\(\\\$this, (\[[^;]*)\);/", $content, $matches);

		$tmpPath = tempnam(sys_get_temp_dir(), "routes-");
		file_put_contents($tmpPath, "<?php\nreturn " . $matches[1] . ";");
		$routes = include($tmpPath);
		unlink($tmpPath);

		return $routes;
	} else {
		throw new Exception("Unknown routes.php format");
	}
}

function cleanDocComment(string $comment): string {
	return trim(preg_replace("/\s+/", " ", $comment));
}

function splitOnUppercaseFollowedByNonUppercase(string $str): array {
	return preg_split('/(?=[A-Z][^A-Z])/', $str, -1, PREG_SPLIT_NO_EMPTY);
}

function mapVerb(string $verb): string {
	return match ($verb) {
		"index" => "list",
		default => $verb,
	};
}